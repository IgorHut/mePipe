# Functions to identify LD structure and group SNPs accordingly
# 
# Author: Peter Humburg
###############################################################################


#' Identify LD blocks around eQTLs
#' @param eqtls A \code{data.frame} with eQTLs as generated by package \code{MatrixEQTL}. 
#' @param genotype A \code{SlicedData} object with genotypes.
#' @param pos A \code{data.frame} with columns \code{chrom} and \code{pos} giving SNP positions.
#' @param dist Maximum allowed distance between adjacent SNPs within an LD block.
#' @param verbose Logical indicating whether additional progress information should be printed.
#' @param window Size of window around each eQTL (in number of SNPs) in which LD 
#' calculations are carried out.
#' @param genoOpt List of options for reading of genotype data.
#' @param minFDR Minimum (FDR) significance level required for a SNP to be reported as part 
#' of a block of associations for a given gene. Only blocks that contain at least one significant
#' SNP at this level will be reported.
#' @return A \code{data.frame} with single SNP eQTLs replaced by associations between LD blocks 
#' and gene expression.
#' @seealso \code{\link{ldBlock}} \code{{\link{getOptions}}}
#' @author Peter Humburg
#' @export
getLDblocks <- function(eqtls, genotype, pos, dist=500, window=200, 
		genoOpt=getOptions(), verbose=FALSE, minFDR=0.05){
	## check inputs
	if(!is(eqtls, "data.frame")){
		stop("Argument ", sQuote("eqtls"), " has to be a ", dQuote("data.frame"))
	}
	if(!"snps" %in% names(eqtls)){
		stop("Argument ", sQuote("eqtls"), " is missing column ", sQuote("snps"))
	}
	if(!is(pos, "data.frame")){
		stop("Argument ", sQuote("pos"), " has to be a ", dQuote("data.frame"))
	}
	if(!all(c("chrom", "pos") %in% names(pos))){
		stop("Argument ", sQuote("pos"), " has to have columns ", sQuote("chrom"), " and ",
				sQuote("pos"))
	}
	
	if(is.null(rownames(pos)) ){
		idx <- which(tolower(colnames(pos)) == "snp" | tolower(colnames(pos)) == "id")
		if(length(idx) == 1){
			rownames(pos) <- as.character(pos[,idx])
		} else{
			stop("Row names of argument ", sQuote("pos"), " should correspond to SNP IDs.")
		}
	}
	
	eqtls <- subset(eqtls, FDR <= minFDR)
	if(nrow(eqtls) > 0){
		chroms <- unique(as.character(pos[rownames(pos) %in% eqtls$snps, "chrom"]))
		ans <- Rsge::sge.parLapply(chroms, .submitLDblocks, genoOpt=genoOpt, 
				genotype=genotype, eqtls=eqtls,	verbose=verbose, pos=pos, dist=dist, 
				window=window, minFDR=minFDR, njobs=length(unique(pos$chrom)))
		ans <- Reduce(rbind, ans)
		
		ans[order(ans$pvalue),]
	}
}

.submitLDblocks <- function(chromosome, genoOpt, genotype, eqtls, verbose, pos, dist, window, minFDR) {
	## load genotypes
	geno <- SlicedData$new();
	geno$fileDelimiter <- genoOpt$sep
	geno$fileOmitCharacters <- genoOpt$missing
	geno$fileSkipRows <- genoOpt$rowskip
	geno$fileSkipColumns <- genoOpt$colskip
	geno$fileSliceSize <- genoOpt$slice
	geno$LoadFile(genotype)
	
	## Compute LD blocks
	eqtls <- subset(eqtls, snps %in% rownames(subset(pos, chrom == chromosome)))
	candidates <- unique(as.character(eqtls$snps))
	blocks <- vector(mode="list", length(candidates))
	nextEntry <- 1
	while(length(candidates) > 0){
		if(verbose) message(" computing LD block for ", candidates[1])
		ans <- ldBlock(candidates[1], geno, pos, dist, window)
		if(!is.null(ans)){
			blocks[[nextEntry]] <- ans
			names(blocks)[nextEntry] <- candidates[1]
			candidates <- setdiff(candidates, blocks[[nextEntry]][["snps"]])
			nextEntry <- nextEntry + 1
		} else{
			candidates <- candidates[-1]
		}
	}
	if(nextEntry <= length(blocks)){
		blocks <- blocks[-(nextEntry:length(blocks))]
	}
	
	if(length(blocks) > 0){
		## link eQTLs to blocks
		eqtls$block <- sapply(eqtls$snps, function(x) which(sapply(blocks, function(y) x %in% y$snps))[1])
		
		## replace single SNP eQTL results with LD block eQTLs
		ans <- by(eqtls, list(eqtls$block, eqtls$gene), 
				function(x){
					peak <- x$snps[which.min(x$FDR)]
					data.frame(chrom=chromosome, start=blocks[[x$block[1]]][["start"]], 
							end=blocks[[x$block[1]]][["end"]], peak=peak, gene=x$gene[1],
							statistic=subset(x, snps==peak)$statistic, 
							pvalue=subset(x, snps==peak)$pvalue, FDR=subset(x, snps==peak)$FDR,
							snps=paste(subset(x, FDR <= minFDR)$snps, collapse=","), 
							stringsAsFactors=FALSE)
				}
		)
		ans <- Reduce(rbind, ans)
	}
	
	ans
}


#' Identify region of high LD around a given SNP
#' @param snp Name (typically the rs ID) of the SNP
#' @param geno An object of class \code{"SnpMatrix"} with genotypes.
#' @param pos A \code{"data.frame"} with columns \code{'chrom'} and \code{'pos'}
#' giving the SNP locations. Row names correspond to SNP IDs. This is assumed to be 
#' sorted by position.
#' @param dist Maximum allowed distance between adjacent SNPs within an LD block.
#' @param window Size of window around \code{snp} (in number of SNPs) in which LD 
#' calculations are carried out.
#' @param ... Further arguments to \code{\link[trio]{findLDBlocks}}
#' @return A list with components \code{chrom}, \code{start}, \code{end} and \code{snps}.
#' 
#' @author Peter Humburg
#' @export
ldBlock <- function(snp, geno, pos, dist=500, window=200, ...){
	ans <- list()
	
	snp <- as.character(snp)
	## identify and extract relevant SNPs
	snpIdx <- which(rownames(pos) == snp)
	if(length(snpIdx) == 0){
		stop("Failed to locate SNP ", snp, " in table of SNP positions.")
	}
	ans$chrom <- pos$chrom[snpIdx]
	selected <- rownames(pos)[
			c(max(1, snpIdx - window):min(nrow(pos), snpIdx + window))
	]
	selected <- selected[pos[selected, "chrom"] == ans$chrom]
	rightEnd <- length(selected)
	leftEnd <- 1
	if(length(selected) > 1){
		gap <- diff(pos[selected, "pos"])
		thisIdx <- which(selected==snp)
		if(thisIdx < length(selected)){
			end <- which(gap[thisIdx:length(gap)] > dist) + thisIdx
			if(length(end)){
				rightEnd <- min(end)
			}
		}
		if(thisIdx > 1){
			end <- which(gap[1:(which(selected==snp)-1)] > dist)
			if(length(end)){
				leftEnd <- max(end)
			}
		}
	}
	selected <- selected[leftEnd:rightEnd]
	regionGeno <- Reduce(rbind, lapply(lapply(selected, geno$FindRow), "[[", "row"))
	
	## compute LD structure
	ldResult <- NULL
	tryCatch(
			ldResult <- trio::getLD(regionGeno, snp.in.col=FALSE, addVarN=TRUE),
			error=function(e){
				warning("Skipping LD computations for ", snp, " due to error in trio::getLD\n", 
						"  Error was \"", e$message, "\"")
			}
	)
	if(!is.null(ldResult)){
		block <- trio::findLDblocks(ldResult, ...)
		
		## extract block for requested SNP
		selBlock <- block$blocks[snp]
		ans$snps <- unique(block$vec.blocks[[as.character(selBlock)]])
		if(is.null(ans$snps)){
			ans$snps <- snp
		}
		ans$start <- min(pos[ans$snps, "pos"])
		ans$end <- max(pos[ans$snps, "pos"])
		
		ans
	}
}

#' Identify all SNPs in LD with peak SNP
#' The resulting list of eSNPs for the same gene may be considered independent signals.
#' @param eqtls A \code{data.frame} with eQTLs as generated by package \code{MatrixEQTL}. 
#' @param genotype A \code{SlicedData} object with genotypes.
#' @param minFDR FDR threshold to use when filtering associations. Only SNPs with an FDR below 
#' this threshold will be considered.
#' @param minR Minimum R-squared required between two eSNPs for them to be considered in LD.
#' @param genoOpt List of options for reading of genotype data.
#' @note Unlike the raw Matrix-eQTL output all associations with an FDR below the threshold indicated
#' by \code{minFDR} will be absent from the output produced by this function.
#' @return A \code{data.frame} containing all significant peak SNPs that are not in (high)
#' LD with more significant SNPs. Columns are the same as in Matrix-eQTL output plus two additional
#' columns (\code{others} and \code{Rsquared}) with comma separated list of SNPs that had 
#' significant p-values but are considered to be proxies of the peak SNP and their R^2. 
#' @author Peter Humburg
#' @export
getLDpairs <- function(eqtls, genotype, minFDR=0.05, minR=0.85, genoOpt=getOptions()){
	## check inputs
	if(!is(eqtls, "data.frame")){
		stop("Argument ", sQuote("eqtls"), " has to be a ", dQuote("data.frame"))
	}
	if(!"snps" %in% names(eqtls)){
		stop("Argument ", sQuote("eqtls"), " is missing column ", sQuote("snps"))
	}
	if(!"gene" %in% names(eqtls)){
		stop("Argument ", sQuote("eqtls"), " is missing column ", sQuote("gene"))
	}
	
	eqtls <- subset(eqtls, FDR <= minFDR)
	ans <- data.frame(snps=character(), gene=character(), statistic=numeric(), 
			pvalue=numeric(), FDR=numeric(), others=character(), Rsquared=character())

	if(nrow(eqtls) > 0){
		## load genotypes
		geno <- SlicedData$new()
		geno$fileDelimiter <- genoOpt$sep
		geno$fileOmitCharacters <- genoOpt$missing
		geno$fileSkipRows <- genoOpt$rowskip
		geno$fileSkipColumns <- genoOpt$colskip
		geno$fileSliceSize <- genoOpt$slice 
		geno$LoadFile(genotype)
		
		## get list of R-sq for between peak SNP for each gene and all other SNPs
		## that have significant associations with that gene
		genes <- unique(as.character(eqtls$gene))
		ans <- sge.parLapply(genes, .submitLDpairs, eqtls=eqtls, geno=geno, minR=minR, 
				genoOpt=genoOpt, njobs=length(genes))
	}
	Reduce(rbind, ans)
}

.submitLDpairs <- function(selGene, eqtls, geno, minR, genoOpt){
	eqtls <- subset(eqtls, gene == selGene)
	eqtls <- eqtls[order(eqtls$pvalue),]
	ans <- data.frame(snps=character(), gene=character(), statistic=numeric(), 
			pvalue=numeric(), FDR=numeric(), others=character(), Rsquared=character(),
			stringsAsFactors=FALSE)
	while(nrow(eqtls) > 0){
		if(nrow(eqtls) == 1){
			eqtls$others <- NA
			eqtls$Rsquared <- NA
			proxies <- data.frame(snps=character(), Rsquared=numeric(), stringsAsFactors=FALSE)
			ans <- rbind(ans, eqtls)
		} else {
			## create CubeX input file for all pairs including the peak SNP
			snpMat <- toCubeX(geno, as.character(eqtls$snps))
			tmp <- tempfile(pattern=paste(selGene, eqtls$snps[1], sep="_"), tmpdir=".", fileext=".tmp")
			write.table(snpMat, file=tmp, row.names=FALSE, col.names=FALSE, sep="\t", quote=FALSE)
			
			## get list of R-sq for between peak SNP for each gene and all other SNPs
			## that have significant associations with that gene
			outFile <- paste(tmp, "out", sep="_")
			command <- paste("python", file.path(path.package("mePipe"), "exec", "cubex-cl.py"), tmp,
					">", outFile)
			system(command)
			
			## parse CubeX output
			cubexOut <- XML::xmlTreeParse(outFile)
			cubexOut <- lapply(XML::xmlChildren(cubexOut$doc$children[["dataset"]]), XML::xmlToList)
			## extract r^2 of most likely solution (assuming HWE and random mating)
			rsq <- numeric()
			for(result in cubexOut){
				chisq <- c(alpha=as.numeric(result[["alpha-chisq"]]), 
						beta=as.numeric(result[["beta-chisq"]]), 
						gamma=as.numeric(result[["gamma-chisq"]]))
				solution <- names(chisq)[which.min(chisq)]
				rsq <- c(rsq, as.numeric(result[[paste0(solution, "rsquared")]]))
			}
			proxies <- data.frame(snps=as.character(eqtls$snps[-1]), Rsquared=rsq, stringsAsFactors=FALSE)
			proxies <-subset(proxies, Rsquared >= minR)
			selected <- eqtls[1,]
			if(nrow(proxies) >= 1){
				selected$others <- paste(proxies$snps, collapse=",")
				selected$Rsquared <- paste(sprintf("%.03f", proxies$Rsquared), collapse=",")
			} else{
				selected$others <- NA
				selected$Rsquared <- NA
			}
			ans <- rbind(ans, selected)
			## clean-up
			unlink(c(tmp, outFile))
		}
		eqtls <- subset(eqtls[-1,], !snps %in% proxies$snps)
	}
	ans
}