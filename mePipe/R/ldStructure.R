# Functions to identify LD structure and group SNPs accordingly
# 
# Author: Peter Humburg
###############################################################################


#' Identify LD blocks around eQTLs
#' @param eqtls A \code{data.frame} with eQTLs as generated by package \code{MatrixEQTL}. 
#' @param genotype A \code{SlicedData} object with genotypes.
#' @param pos A \code{data.frame} with columns \code{chrom} and \code{pos} giving SNP positions.
#' @param dist Maximum allowed distance between adjacent SNPs within an LD block.
#' @param verbose Logical indicating whether additional progress information should be printed.
#' @param window Size of window around each eQTL (in number of SNPs) in which LD 
#' calculations are carried out.
#' @param genoOpt List of options for reading of genotype data.
#' @param minFDR Minimum FDR required for a SNP to be reported as part of a block of associations
#' for a given gene.
#' @return A \code{data.frame} with single SNP eQTLs replaced by associations between LD blocks 
#' and gene expression.
#' @seealso \code{\link{ldBlock}} \code{{\link{getOptions}}}
#' @author Peter Humburg
#' @export
getLDblocks <- function(eqtls, genotype, pos, dist=500, window=200, 
		genoOpt=getOptions(), verbose=FALSE, minFDR=0.05){
	## check inputs
	if(!is(eqtls, "data.frame")){
		stop("Argument ", sQuote("eqtls"), " has to be a ", dQuote("data.frame"))
	}
	if(!"snps" %in% names(eqtls)){
		stop("Argument ", sQuote("eqtls"), " is missing column ", sQuote("snps"))
	}
	if(!is(pos, "data.frame")){
		stop("Argument ", sQuote("pos"), " has to be a ", dQuote("data.frame"))
	}
	if(!all(c("chrom", "pos") %in% names(pos))){
		stop("Argument ", sQuote("pos"), " has to have columns ", sQuote("chrom"), " and ",
				sQuote("pos"))
	}
	
	if(is.null(rownames(pos)) ){
		idx <- which(tolower(colnames(pos)) == "snp" | tolower(colnames(pos)) == "id")
		if(length(idx) == 1){
			rownames(pos) <- as.character(pos[,idx])
		} else{
			stop("Row names of argument ", sQuote("pos"), " should correspond to SNP IDs.")
		}
	}
	chroms <- unique(subset(pos, rownames(pos) %in% eqtls$snp)$pos)
	if(sge.getOption("sge.use.cluster")){
		ans <- Rsge::sge.parParApply(chroms, .submitLDblocks, genoOpt=genoOpt, 
				genotype=genotype, eqtls=eqtls,	verbose=verbose, pos=pos, dist=dist, 
				window=window, minFDR=minFDR, nobj=length(unique(pos$chrom)))
	} else{
		ans <- lapply(chroms, .submitLDblocks, genoOpt=genoOpt, 
				genotype=genotype, eqtls=eqtls,	verbose=verbose, pos=pos, dist=dist, 
				window=window, minFDR=minFDR)
	}
	ans <- Reduce(rbind, ans)
	
	ans[order(ans$pvalue),]
}

.submitLDblocks <- function(chrom, genoOpt, genotype, eqtls, verbose, pos, dist, window, minFDR) {
	## load genotypes
	geno <- SlicedData$new();
	geno$fileDelimiter <- genoOpt$sep
	geno$fileOmitCharacters <- genoOpt$missing
	geno$fileSkipRows <- genoOpt$rowskip
	geno$fileSkipColumns <- genoOpt$colskip
	geno$fileSliceSize <- genoOpt$slice
	geno$LoadFile(genotype)
	
	## Compute LD blocks
	eqtls <- subset(eqtls, snps %in% rownames(subset(pos, chrom == chrom)))
	candidates <- unique(as.character(eqtls$snps))
	blocks <- vector(mode="list", length(candidates))
	nextEntry <- 1
	while(length(candidates) > 0){
		if(verbose) message(" computing LD block for ", candidates[1])
		blocks[[nextEntry]] <- ldBlock(candidates[1], geno, pos, dist, window)
		if(!is.null(blocks[[nextEntry]])){
			names(blocks)[nextEntry] <- candidates[1]
			candidates <- setdiff(candidates, blocks[[nextEntry]][["snps"]])
			nextEntry <- nextEntry + 1
		} else{
			candidates <- candidates[-1]
		}
	}
	if(nextEntry <= length(blocks)){
		blocks <- blocks[-(nextEntry:length(blocks))]
	}
	
	## link eQTLs to blocks
	eqtls$block <- sapply(eqtls$snps, function(x) which(sapply(blocks, function(y) x %in% y$snps))[1])
	
	## replace single SNP eQTL results with LD block eQTLs
	ans <- by(eqtls, list(eqtls$block, eqtls$gene), 
			function(x){
				peak <- x$snps[which.min(x$FDR)]
				data.frame(chrom=eqtls$chrom[1], start=blocks[[x$block]][["start"]], 
						end=blocks[[x$block]][["end"]], peak=x$snps[peak], gene=x$gene[1],
						statistic=x[[3]][peak], pvalue=x[["p-value"]][peak], FDR=x[["FDR"]][peak],
						snps=paste(subset(x, FDR <= minFDR)$snps, collapse=","), stringsAsFactors=FALSE)
			}
	)
	ans <- Reduce(rbind, ans)
}


#' Identify region of high LD around a given SNP
#' @param snp Name (typically the rs ID) of the SNP
#' @param geno An object of class \code{"SnpMatrix"} with genotypes.
#' @param pos A \code{"data.frame"} with columns \code{'chrom'} and \code{'pos'}
#' giving the SNP locations. Row names correspond to SNP IDs. This is assumed to be 
#' sorted by position.
#' @param dist Maximum allowed distance between adjacent SNPs within an LD block.
#' @param window Size of window around \code{snp} (in number of SNPs) in which LD 
#' calculations are carried out.
#' @param ... Further arguments to \code{\link[trio]{findLDBlocks}}
#' @return A list with components \code{chrom}, \code{start}, \code{end} and \code{snps}.
#' 
#' @author Peter Humburg
#' @export
ldBlock <- function(snp, geno, pos, dist=500, window=200, ...){
	ans <- list()
	
	snp <- as.character(snp)
	## identify and extract relevant SNPs
	snpIdx <- which(rownames(pos) == snp)
	if(length(snpIdx) == 0){
		stop("Failed to locate SNP ", snp, " in table of SNP positions.")
	}
	ans$chrom <- pos$chrom[snpIdx]
	selected <- rownames(pos)[
			c(max(1, snpIdx - window):min(nrow(pos), snpIdx + window))
	]
	selected <- selected[pos[selected, "chrom"] == ans$chrom]
	rightEnd <- length(selected)
	leftEnd <- 1
	if(length(selected) > 1){
		gap <- diff(pos[selected, "pos"])
		thisIdx <- which(selected==snp)
		if(thisIdx < length(selected)){
			end <- which(gap[thisIdx:length(gap)] > dist) + thisIdx
			if(length(end)){
				rightEnd <- min(end)
			}
		}
		if(thisIdx > 1){
			end <- which(gap[1:(which(selected==snp)-1)] > dist)
			if(length(end)){
				leftEnd <- max(end)
			}
		}
	}
	selected <- selected[leftEnd:rightEnd]
	regionGeno <- Reduce(rbind, lapply(lapply(selected, geno$FindRow), "[[", "row"))
	
	## compute LD structure
	ldResult <- NULL
	tryCatch(
			ldResult <- trio::getLD(regionGeno, snp.in.col=FALSE, addVarN=TRUE),
			error=function(e){
				warning("Skipping LD computations for ", snp, " due to error in trio::getLD\n", 
						"  Error was \"", e$message, "\"")
			}
	)
	if(!is.null(ldResult)){
		block <- trio::findLDblocks(ldResult, ...)
		
		## extract block for requested SNP
		selBlock <- block$blocks[snp]
		ans$snps <- unique(block$vec.blocks[[as.character(selBlock)]])
		if(is.null(ans$snps)){
			ans$snps <- snp
		}
		ans$start <- min(pos[ans$snps, "pos"])
		ans$end <- max(pos[ans$snps, "pos"])
		
		ans
	}
}